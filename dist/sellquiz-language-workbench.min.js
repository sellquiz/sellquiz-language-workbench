var slw = (function (exports, codemirror, sellquiz, nspell) {
  'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  }

  var codemirror__namespace = /*#__PURE__*/_interopNamespace(codemirror);
  var sellquiz__namespace = /*#__PURE__*/_interopNamespace(sellquiz);
  var nspell__default = /*#__PURE__*/_interopDefaultLegacy(nspell);

  // CodeMirror, copyright (c) by Marijn Haverbeke and others
  // Distributed under an MIT license: https://codemirror.net/LICENSE
  (function (mod) {
    if (typeof exports == "object" && typeof module == "object") // CommonJS
      mod(require("../../lib/codemirror"));else if (typeof define == "function" && define.amd) // AMD
      define(["../../lib/codemirror"], mod);else // Plain browser env
      mod(CodeMirror);
  })(function (CodeMirror) {

    var WRAP_CLASS = "CodeMirror-activeline";
    var BACK_CLASS = "CodeMirror-activeline-background";
    var GUTT_CLASS = "CodeMirror-activeline-gutter";
    CodeMirror.defineOption("styleActiveLine", false, function (cm, val, old) {
      var prev = old == CodeMirror.Init ? false : old;
      if (val == prev) return;

      if (prev) {
        cm.off("beforeSelectionChange", selectionChange);
        clearActiveLines(cm);
        delete cm.state.activeLines;
      }

      if (val) {
        cm.state.activeLines = [];
        updateActiveLines(cm, cm.listSelections());
        cm.on("beforeSelectionChange", selectionChange);
      }
    });

    function clearActiveLines(cm) {
      for (var i = 0; i < cm.state.activeLines.length; i++) {
        cm.removeLineClass(cm.state.activeLines[i], "wrap", WRAP_CLASS);
        cm.removeLineClass(cm.state.activeLines[i], "background", BACK_CLASS);
        cm.removeLineClass(cm.state.activeLines[i], "gutter", GUTT_CLASS);
      }
    }

    function sameArray(a, b) {
      if (a.length != b.length) return false;

      for (var i = 0; i < a.length; i++) if (a[i] != b[i]) return false;

      return true;
    }

    function updateActiveLines(cm, ranges) {
      var active = [];

      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        var option = cm.getOption("styleActiveLine");
        if (typeof option == "object" && option.nonEmpty ? range.anchor.line != range.head.line : !range.empty()) continue;
        var line = cm.getLineHandleVisualStart(range.head.line);
        if (active[active.length - 1] != line) active.push(line);
      }

      if (sameArray(cm.state.activeLines, active)) return;
      cm.operation(function () {
        clearActiveLines(cm);

        for (var i = 0; i < active.length; i++) {
          cm.addLineClass(active[i], "wrap", WRAP_CLASS);
          cm.addLineClass(active[i], "background", BACK_CLASS);
          cm.addLineClass(active[i], "gutter", GUTT_CLASS);
        }

        cm.state.activeLines = active;
      });
    }

    function selectionChange(cm, sel) {
      updateActiveLines(cm, sel.ranges);
    }
  });

  /******************************************************************************
   * SELLQUIZ-LANGUAGE-WORKBENCH                                                *
   *                                                                            *
   * Copyright (c) 2019-2021 TH Köln                                            *
   * Author: Andreas Schwenk, contact@compiler-construction.com                 *
   *                                                                            *
   * Partly funded by: Digitale Hochschule NRW                                  *
   * https://www.dh.nrw/kooperationen/hm4mint.nrw-31                            *
   *                                                                            *
   * GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007                         *
   *                                                                            *
   * This library is licensed as described in LICENSE, which you should have    *
   * received as part of this distribution.                                     *
   *                                                                            *
   * This software is distributed on "AS IS" basis, WITHOUT WARRENTY OF ANY     *
   * KIND, either impressed or implied.                                         *
   ******************************************************************************/
  var language = "de";
  const checkmark = ' &#x2705; ';
  const crossmark = ' &#x274C; ';
  const lang_str = {
    "definition_en": "Definition",
    "definition_de": "Definition",
    "theorem_en": "Theorem",
    "theorem_de": "Satz",
    "remark_en": "Remark",
    "remark_de": "Bemerkung",
    "please_wait_en": "please wait...",
    "please_wait_de": "bitte warten...",
    "evaluate_en": "Evaluate",
    "evaluate_de": "Auswerten"
  };
  function text(id) {
    if (!(id + "_" + language in lang_str)) return "LANG.text('" + id + "'): unknown!";
    return lang_str[id + "_" + language];
  }

  /******************************************************************************
   * SELLQUIZ-LANGUAGE-WORKBENCH                                                *
   *                                                                            *
   * Copyright (c) 2019-2021 TH Köln                                            *
   * Author: Andreas Schwenk, contact@compiler-construction.com                 *
   *                                                                            *
   * Partly funded by: Digitale Hochschule NRW                                  *
   * https://www.dh.nrw/kooperationen/hm4mint.nrw-31                            *
   *                                                                            *
   * GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007                         *
   *                                                                            *
   * This library is licensed as described in LICENSE, which you should have    *
   * received as part of this distribution.                                     *
   *                                                                            *
   * This software is distributed on "AS IS" basis, WITHOUT WARRENTY OF ANY     *
   * KIND, either impressed or implied.                                         *
   ******************************************************************************/
  //let LZString = require('lz-string');
  //import {decompress} from 'lz-string';
  //import * as LZString from 'lz-string';

  class Spell {
    constructor() {
      this.aff = {};
      this.dic = {};
      this.spell = null; // TODO: multiple languages

      this.load();
    }

    isCorrect(word) {
      if (this.spell == null) return true;
      return this.spell.correct(word);
    }

    getSuggestions(word) {
      return this.spell.suggest(word);
    }

    load(lang = "en") {
      let this_ = this; // load 'aff'

      $.ajax({
        type: "POST",
        dataType: "text",
        mimeType: 'text/plain; charset=x-user-defined',
        //url: "../cache/dict-" + lang + "-compr.aff",
        url: "node_modules/dictionary-" + lang + "/index.aff",
        data: {},
        success: function (data) {
          this_.aff[lang] = data; // LZString.decompress(data);
          // load 'dic

          $.ajax({
            type: "POST",
            dataType: "text",
            mimeType: 'text/plain; charset=x-user-defined',
            //url: "../cache/dict-" + lang + "-compr.dic",
            url: "node_modules/dictionary-" + lang + "/index.dic",
            data: {},
            success: function (data) {
              this_.dic[lang] = data; // LZString.decompress(data);

              this_.spell = nspell__default["default"](this_.aff["en"], this_.dic["en"]);
              update();
            },
            error: function (xhr, status, error) {
              console.error(xhr); // TODO: error handling!
            }
          });
        },
        error: function (xhr, status, error) {
          console.error(xhr); // TODO: error handling!
        }
      });
      return true;
    }

  }

  /******************************************************************************
   * SELLQUIZ-LANGUAGE-WORKBENCH                                                *
   *                                                                            *
   * Copyright (c) 2019-2021 TH Köln                                            *
   * Author: Andreas Schwenk, contact@compiler-construction.com                 *
   *                                                                            *
   * Partly funded by: Digitale Hochschule NRW                                  *
   * https://www.dh.nrw/kooperationen/hm4mint.nrw-31                            *
   *                                                                            *
   * GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007                         *
   *                                                                            *
   * This library is licensed as described in LICENSE, which you should have    *
   * received as part of this distribution.                                     *
   *                                                                            *
   * This software is distributed on "AS IS" basis, WITHOUT WARRENTY OF ANY     *
   * KIND, either impressed or implied.                                         *
   ******************************************************************************/
  const moodle_XML_stack_template = `
<?xml version="1.0" encoding="UTF-8"?>
<quiz>
  <question type="stack">
    <name>
      <text>@TITLE@</text>
    </name>
    <questiontext format="html">
      <text><![CDATA[@QUESTION_TEXT@]]></text>
    </questiontext>
    <generalfeedback format="html">
      <text><![CDATA[@SOLUTION@]]></text>
    </generalfeedback>
    <defaultgrade>1</defaultgrade>
    <penalty>0.1</penalty>
    <hidden>0</hidden>
    <idnumber></idnumber>
    <stackversion>
      <text>2020120600</text>
    </stackversion>
    <questionvariables>
      <text>@VARIABLES@</text>
    </questionvariables>
    <specificfeedback format="html">
      <text><![CDATA[<h4><br></h4>]]></text>
    </specificfeedback>
    <questionnote>
      <text>n</text>
    </questionnote>
    <questionsimplify>1</questionsimplify>
    <assumepositive>0</assumepositive>
    <assumereal>0</assumereal>
    <prtcorrect format="html">
      <text>@TEXT_CORRECT@</text>
    </prtcorrect>
    <prtpartiallycorrect format="html">
      <text>@TEXT_PARTIALLY_CORRECT@</text>
    </prtpartiallycorrect>
    <prtincorrect format="html">
      <text>@TEXT_NOT_CORRECT@</text>
    </prtincorrect>
    <multiplicationsign>dot</multiplicationsign>
    <sqrtsign>1</sqrtsign>
    <complexno>i</complexno>
    <inversetrig>cos-1</inversetrig>
    <logicsymbol>lang</logicsymbol>
    <matrixparens>(</matrixparens>
    <variantsselectionseed></variantsselectionseed>
    @INPUTS@
    @PRTS@
    <tags>
      @TAGS
    </tags>
  </question>
</quiz>
`;

  /******************************************************************************
   * SELLQUIZ-LANGUAGE-WORKBENCH                                                *
   *                                                                            *
   * Copyright (c) 2019-2021 TH Köln                                            *
   * Author: Andreas Schwenk, contact@compiler-construction.com                 *
   *                                                                            *
   * Partly funded by: Digitale Hochschule NRW                                  *
   * https://www.dh.nrw/kooperationen/hm4mint.nrw-31                            *
   *                                                                            *
   * GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007                         *
   *                                                                            *
   * This library is licensed as described in LICENSE, which you should have    *
   * received as part of this distribution.                                     *
   *                                                                            *
   * This software is distributed on "AS IS" basis, WITHOUT WARRENTY OF ANY     *
   * KIND, either impressed or implied.                                         *
   ******************************************************************************/
  class SellQuiz {
    constructor() {
      this.id = 0;
      this.src = "";
    }

  }

  class StackQuizInput {
    constructor() {
      this.ident = ""; // TODO: kind of evaluation (e.g. algebraic, numeric, ...)
    }

  }

  class StackQuiz {
    constructor() {
      this.id = 0;
      this.title = "";
      this.code = "";
      this.text = "";
      this.solutiontext = "";
      this.error = "";
      this.solution = {};
      this.inputs = [];
      this.taglist = [];
    }

    compileCode(code) {
      let output = ""; // fix code. TODO: fix STACK random functions!!

      let lines = code.split("\n");
      output = "display2d:false;\n";
      output += "stardisp:true;\n";
      output += "e:%e;\n";
      output += "i:%i;\n";

      for (let i = 0; i < lines.length; i++) {
        if (lines[i].startsWith(" ") || lines[i].startsWith("\t")) continue;
        let line = lines[i].trim();
        if (line.length == 0) continue;
        if (line.endsWith(";") == false) line += ";";
        output += line + "\n";
      }

      return output;
    }

    evaluate() {
      for (let i = 0; i < this.inputs.length; i++) {
        let input = this.inputs[i];
        let studentAnwser = document.getElementById("stackquiz-" + this.id + "-input-" + input.ident).value;
        let feedbackElement = document.getElementById("stackquiz-" + this.id + "-feedback-" + input.ident); // TODO: evaluation depends on whether we compare terms or floats or ...

        if (Math.abs(parseFloat(this.solution[input.ident + "_float"]) - parseFloat(studentAnwser)) < 1e-5) {
          feedbackElement.innerHTML = checkmark;
        } else {
          feedbackElement.innerHTML = crossmark;
        }
      }
    }

    refresh() {
      if (this.error.length > 0) return; // call maxima

      let service_url = "services/maxima.php";

      let _this = this;

      $.ajax({
        type: "POST",
        url: service_url,
        data: {
          input: this.code
        },
        success: function (data) {
          //console.log(data);
          let lines = data.split("\n");
          let state = "";
          let values = "";
          let evalValues = "";
          let evalValuesFloat = "";

          for (let i = 0; i < lines.length; i++) {
            let line = lines[i].trim();

            if (line.endsWith(") values")) {
              state = "v";
            } else if (line.endsWith(") ev(values)")) {
              state = "ev";
            } else if (line.endsWith(") float(ev(values))")) {
              state = "ev_float";
            } else if (state == "v") {
              //console.log(line);
              values = line;
              state = "";
            } else if (state == "ev") {
              //console.log(line);
              evalValues = line;
              state = "";
            } else if (state == "ev_float") {
              //console.log(line);
              evalValuesFloat = line;
              state = "";
            }
          } // parse values


          let start = 0;

          for (let i = 0; i < values.length; i++) {
            if (values[i] == ")") {
              start = i + 3;
              break;
            }
          }

          let valuesArr = values.substring(start, values.length - 1).trim().split(","); //console.log(valuesArr);
          // parse evaluation result: TODO: this may not work for matrices, sets, text, ...

          start = 0;

          for (let i = 0; i < evalValues.length; i++) {
            if (evalValues[i] == ")") {
              start = i + 3;
              break;
            }
          }

          let evalValuesArr = evalValues.substring(start, evalValues.length - 1).trim().split(","); //console.log(evalValuesArr);
          // parse float values

          start = 0;

          for (let i = 0; i < evalValuesFloat.length; i++) {
            if (evalValuesFloat[i] == ")") {
              start = i + 3;
              break;
            }
          }

          let evalValuesArrFloat = evalValuesFloat.substring(start, evalValuesFloat.length - 1).trim().split(","); //console.log(evalValuesArrFloat);
          //alert(_this.solution)
          // TODO: assert equal length of values and evalValues!

          for (let i = 0; i < valuesArr.length; i++) {
            _this.solution[valuesArr[i]] = evalValuesArr[i];
            _this.solution[valuesArr[i] + "_float"] = evalValuesArrFloat[i];
          } //console.log(_this.solution);


          _this.updateHTML(); //setTimeout(function(){ mathjax.typeset(); }, 250); // TODO: do not call this for EVERY quiz separately, but only when LAST quiz is ready

        },
        error: function (xhr, status, error) {
          console.error(xhr); // TODO: error handling!
        }
      });
    }

    placeVariables_ident(ident, hashtag) {
      let output = "";

      if (["e", "i"].includes(ident) == false && ident in this.solution) {
        if (hashtag) {
          // input field
          let inputwidth = 5; // TODO

          let input = new StackQuizInput();
          input.ident = ident;
          this.inputs.push(input);
          let inputfield = '` <input type="text" value="" id="stackquiz-' + this.id + '-input-' + ident + '" size="' + inputwidth + '" placeholder=""> ';
          output += inputfield;
          let feedback = ' <span id="stackquiz-' + this.id + '-feedback-' + ident + '"></span>` ';
          output += feedback;
        } else output += this.solution[ident];
      } else output += ident;

      return output;
    }

    placeVariables(input) {
      let output = "";
      let state = "";
      let ident = "";
      let hashtag = false;
      const n = input.length;

      for (let i = 0; i < n; i++) {
        let ch = input[i];

        if (ch == '`') {
          state = state == '$' ? '' : '$';

          if (ident.length > 0) {
            output += this.placeVariables_ident(ident, hashtag);
            ident = "";
          }

          output += ch;
        } else if (state == '$') {
          if (ch >= 'A' && ch <= 'Z' || ch >= 'a' && ch <= 'z'
          /*|| (ch=='_')*/
          ) {
            ident += ch;
          } else if (ident.length > 0 && ch >= '0' && ch <= '9') {
            ident += ch;
          } else {
            if (ident.length > 0) {
              output += this.placeVariables_ident(ident, hashtag);
              ident = "";
            }

            if (ch == '#') hashtag = true;else {
              hashtag = false;
              output += ch;
            }
          }
        } else {
          output += ch;
        }
      } //console.log("#####" + output)


      return output;
    }

    updateHTML() {
      let html = "";

      if (this.error.length > 0) {
        html += "<div class=\"card border-dark\">";
        html += "<div class=\"card-body\">\n";
        html += "<span class=\"h2 py-1 my-1\">" + '<i class="fas fa-question-circle"></i> ' + "Stack-Quiz: ERROR" + "</span><br/>\n";
        html += "<p class=\"text-danger\">" + this.error + "</p>";
        html += "</div>\n"; // end of card body

        html += "</div>\n"; // end of card
      } else {
        // get variaables
        let var_text = "";

        for (let sol in this.solution) {
          if (["e", "i"].includes(sol)) continue;
          if (sol.endsWith("_float")) continue;
          if (var_text.length > 0) var_text += ", ";
          var_text += sol + "=" + this.solution[sol] + " (" + this.solution[sol + "_float"] + ")";
        } // create HTML


        html += "<div class=\"card border-dark\">";
        html += "<div class=\"card-body\">\n"; // title

        html += "<span class=\"h2 py-1 my-1\">" + '<i class="fas fa-question-circle"></i> ' + this.title + "</span><br/>\n"; // text (with replaced variables)

        html += this.placeVariables(this.text); // TODO: must trigger tooltip-update!

        html += '<button type="button" class="btn btn-primary" onclick="slw.eval_stack(\'' + this.id + '\');">' + text("evaluate") + '</button>' + ' ';
        html += '<button type="button" class="btn btn-outline-primary" data-bs-toggle="tooltip" data-bs-placement="bottom" title="export to Moodle-XML" onclick="slw.export_stack(' + this.id + ')"><i class="fas fa-file-export"></i></button>' + ' ';
        html += '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span id="general_feedback"></span><br/>';
        html += "</div>\n"; // end of card body

        html += "<div class=\"card-footer text-muted\">";
        html += "<b>Variablen:</b>"; // TODO: language

        html += "<p class=\"font-monospace\">" + var_text + "</p>";
        html += "</div>\n"; // end of card footer

        html += "<div class=\"card-footer text-muted\">";
        html += "<b>Lösung:</b> ";
        html += this.placeVariables(this.solutiontext);
        html += "</div>\n"; // end of card footer

        html += "</div>\n"; // end of card
      }

      document.getElementById("stackquiz-" + this.id).innerHTML = html;
      eval("typeset();");
    }

    exportMoodleXML() {
      let mxml = moodle_XML_stack_template;
      mxml = mxml.replaceAll("@TITLE@", this.title); // TODO: must replace random functions!!

      mxml = mxml.replaceAll("@VARIABLES@", this.code);
      mxml = mxml.replaceAll("@TEXT_CORRECT@", text("moodle_correct"));
      mxml = mxml.replaceAll("@TEXT_PARTIALLY_CORRECT@", text("moodle_partially_correct"));
      mxml = mxml.replaceAll("@TEXT_NOT_CORRECT@", text("moodle_not_correct"));
      mxml = mxml.replaceAll("@TAGS@", ""); // TODO (must refer to example file!!)
      // TODO: inputs, prts

      alert(mxml);
    }

  }

  /******************************************************************************
   * SELLQUIZ-LANGUAGE-WORKBENCH                                                *
   *                                                                            *
   * Copyright (c) 2019-2021 TH Köln                                            *
   * Author: Andreas Schwenk, contact@compiler-construction.com                 *
   *                                                                            *
   * Partly funded by: Digitale Hochschule NRW                                  *
   * https://www.dh.nrw/kooperationen/hm4mint.nrw-31                            *
   *                                                                            *
   * GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007                         *
   *                                                                            *
   * This library is licensed as described in LICENSE, which you should have    *
   * received as part of this distribution.                                     *
   *                                                                            *
   * This software is distributed on "AS IS" basis, WITHOUT WARRENTY OF ANY     *
   * KIND, either impressed or implied.                                         *
   ******************************************************************************/
  var ProgrammingQuizType;

  (function (ProgrammingQuizType) {
    ProgrammingQuizType[ProgrammingQuizType["JavaBlock"] = 0] = "JavaBlock";
  })(ProgrammingQuizType || (ProgrammingQuizType = {}));
  class PorgrammingQuiz {
    constructor() {
      this.id = 0;
      this.type = ProgrammingQuizType.JavaBlock;
      this.title = "";
      this.text = "";
      this.given = "";
      this.asserts = [];
      this.forbiddenKeywords = [];
      this.requiredKeywords = [];
      this.solution = "";
      this.editor = null;
    }

    refresh() {// TODO
    }

    evaluate() {
      let src = this.editor.getValue().split("\n"); // restore given source code:

      let givenSrc = this.given.split("\n");
      let restored_src = '';

      for (let i = 0; i < src.length; i++) {
        if (i < givenSrc.length) restored_src += givenSrc[i] + "\n";else restored_src += src[i] + "\n";
      }

      restored_src = restored_src.replaceAll("§", ""); // 

      let task = {
        "type": "JavaBlock",
        "source": restored_src,
        "asserts": this.asserts,
        "language": language
      };
      let service_url = "services/prog.php"; // TODO: should forbid running twice at the same time!!!!!

      let feedback_htmlElement = document.getElementById("programming-feedback-" + this.id);
      let wait_text = text("please_wait");
      feedback_htmlElement.innerHTML = "<span class=\"text-danger\">" + wait_text + "</span>";
      $.ajax({
        type: "POST",
        url: service_url,
        data: {
          input: JSON.stringify(task)
        },
        success: function (data) {
          data = JSON.parse(data);
          let status = data["status"];
          let message = data["msg"];
          feedback_htmlElement.innerHTML = (status === "ok" ? checkmark : crossmark) + " ";
          feedback_htmlElement.innerHTML += ' &nbsp; <code>' + message.replaceAll("\n", "<br/>").replaceAll(" ", "&nbsp;") + '</code>';
        },
        error: function (xhr, status, error) {
          console.error(xhr); // TODO: error handling!
        }
      });
    }

    updateHTML() {
      let html = "";
      html += "<div class=\"card border-dark\">";
      html += "<div class=\"card-body\">\n";
      html += "<span class=\"h2 py-1 my-1\">" + '<i class="fas fa-keyboard"></i> ' + this.title + "</span><br/>\n";
      html += this.text;
      html += '<div class="border p-0 m-0"><textarea class="form-control p-0" style="min-width: 100%;" id="programming-editor-' + this.id + '" + rows="5"></textarea></div>';
      html += '<p id="programming-feedback-' + this.id + '"></p>';
      let evalStr = "Auswerten"; // TODO: language!

      html += '<button type="button" class="btn btn-primary" onclick="slw.eval_prog(\'' + this.id + '\')">' + evalStr + '</button>' + ' ';
      html += "</div>\n"; // end of card body

      html += "</div>\n"; // end of card

      document.getElementById("programming-" + this.id).innerHTML = html;
      this.editor = codemirror__namespace.fromTextArea(document.getElementById("programming-editor-" + this.id), {
        mode: "text/x-java",
        lineNumbers: true,
        lineWrapping: true
        /*
        styleActiveLine: {
        nonEmpty: true
        },*/

      }); // hide everything between a pair of '§'

      let givenSrc = this.given.replace(/§\d*§/g, "?") + "\n";
      this.editor.setValue(givenSrc); // forbid changing given code

      let this_ = this;
      this.editor.on('beforeChange', function (cm, change) {
        if (change.from.line < this_.given.split("\n").length - 1) {
          change.cancel();
        }
      }); // TODO: background color for static lines
      // this.editor.addLineClass(0, "background", "highlighted-line");
    }

  }

  /******************************************************************************
   * SELLQUIZ-LANGUAGE-WORKBENCH                                                *
   *                                                                            *
   * Copyright (c) 2019-2021 TH Köln                                            *
   * Author: Andreas Schwenk, contact@compiler-construction.com                 *
   *                                                                            *
   * Partly funded by: Digitale Hochschule NRW                                  *
   * https://www.dh.nrw/kooperationen/hm4mint.nrw-31                            *
   *                                                                            *
   * GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007                         *
   *                                                                            *
   * This library is licensed as described in LICENSE, which you should have    *
   * received as part of this distribution.                                     *
   *                                                                            *
   * This software is distributed on "AS IS" basis, WITHOUT WARRENTY OF ANY     *
   * KIND, either impressed or implied.                                         *
   ******************************************************************************/
  // TODO: must clear cache
  var cache = {};
  class Plot2d {
    constructor() {
      this.id = 0;
      this.title = "";
      this.src = "";
    }

    error(message) {
      let imgElement = document.getElementById("plot2d-img-" + this.id);
      imgElement.innerHTML = "<p class=\"text-danger\">Error: " + message + "</p>";
    }

    setImage(data) {
      let imgElement = document.getElementById("plot2d-img-" + this.id); // TODO: image size

      imgElement.innerHTML = "<img src=\"" + data + "\" class=\"img-fluid\" width=\"320px\"/>";
    }

    refresh() {
      if (this.src in cache) {
        this.setImage(cache[this.src]);
        return;
      } // TODO: asciimath to tex


      let tex = `\\documentclass[class=minimal,border=0pt]{standalone}
\\usepackage[latin1]{inputenc}
\\usepackage{tikz}
\\begin{document}
\\pagestyle{empty}
\\begin{tikzpicture}[domain=_X_START_:_X_END_]
    \\draw[very thin,color=gray] _GRID_START_ grid _GRID_END_;
    \\draw[->] _X_AXIS_START_ -- _X_AXIS_END_ node[right] {$x$};
    \\draw[->] _Y_AXIS_START_ -- _Y_AXIS_END_ node[above] {$y$};
_FUNCTIONS_
\\end{tikzpicture}
\\end{document}
`; // create LaTeX file

      let x1 = -1;
      let x2 = 1;
      let y1 = -1;
      let y2 = 1;
      let functions = "";
      let function_idx = 0;
      let lines = this.src.split("\n");

      for (let i = 0; i < lines.length; i++) {
        let line = lines[i];
        if (line.trim().length == 0) continue;

        if (line.startsWith("xaxis") || line.startsWith("yaxis")) {
          let isXAxis = line.startsWith("xaxis");
          let values = line.substr(5).trim().split(",");

          if (values.length != 2 || isNaN(parseFloat(values[0])) || isNaN(parseFloat(values[1]))) {
            this.error("Definition of 'xaxis' must have format 'xaxis START, END'");
            return;
          }

          if (isXAxis) {
            x1 = parseFloat(values[0]);
            x2 = parseFloat(values[1]);
          } else {
            y1 = parseFloat(values[0]);
            y2 = parseFloat(values[1]);
          }
        } else if (line.startsWith("plot")) {
          // TODO: must check, if term is correct!
          let tokens = line.substr(4).trim().split("=");

          if (tokens.length != 2) {
            this.error("Definition of 'plot' must have format 'plot ID = TERM'");
            return;
          }

          let id = tokens[0].trim();
          let fct = tokens[1].trim();
          let colors = ["red", "blue", "orange"]; // TODO

          functions += "\t\\draw[color=" + colors[function_idx % colors.length] + "] plot function{" + fct + "}\n";
          functions += "\t\tnode[right] {$" + id + "$};\n";
          function_idx++;
        } else {
          this.error("unknown command in line: '" + line + "'");
          return;
        }
      }

      tex = tex.replaceAll("_X_START_", "" + x1);
      tex = tex.replaceAll("_X_END_", "" + x2);
      tex = tex.replaceAll("_GRID_START_", "(" + (x1 - 0.1) + "," + (y1 - 0.1) + ")");
      tex = tex.replaceAll("_GRID_END_", "(" + (x2 + 0.1) + "," + (y2 + 0.1) + ")");
      tex = tex.replaceAll("_X_AXIS_START_", "(" + (x1 - 0.2) + "," + 0.0 + ")");
      tex = tex.replaceAll("_X_AXIS_END_", "(" + (x2 + 0.2) + "," + 0.0 + ")");
      tex = tex.replaceAll("_Y_AXIS_START_", "(" + 0 + "," + (y1 - 0.2) + ")");
      tex = tex.replaceAll("_Y_AXIS_END_", "(" + 0 + "," + (y2 + 0.2) + ")");
      tex = tex.replaceAll("_FUNCTIONS_", functions); // render via LaTeX + Gnuplot

      let service_url = "services/plot2d.php";
      let this_ = this;
      $.ajax({
        type: "POST",
        url: service_url,
        data: {
          input: tex
        },
        success: function (data) {
          cache[this_.src] = data;
          this_.setImage(data);
        },
        error: function (xhr, status, error) {
          console.error(xhr); // TODO: error handling!
        }
      });
    }

    updateHTML() {
      let html = "";
      html += "<div class=\"card border-dark\">";
      html += "<div class=\"card-body\">\n";
      html += "<span class=\"h2 py-1 my-1\">" + this.title + "</span><br/>\n";
      html += '<p id="plot2d-img-' + this.id + '"></p>';
      html += "</div>\n"; // end of card footer

      html += "</div>\n"; // end of card

      document.getElementById("plot2d-" + this.id).innerHTML = html;
    }

  }

  /******************************************************************************
   * SELLQUIZ-LANGUAGE-WORKBENCH                                                *
   *                                                                            *
   * Copyright (c) 2019-2021 TH Köln                                            *
   * Author: Andreas Schwenk, contact@compiler-construction.com                 *
   *                                                                            *
   * Partly funded by: Digitale Hochschule NRW                                  *
   * https://www.dh.nrw/kooperationen/hm4mint.nrw-31                            *
   *                                                                            *
   * GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007                         *
   *                                                                            *
   * This library is licensed as described in LICENSE, which you should have    *
   * received as part of this distribution.                                     *
   *                                                                            *
   * This software is distributed on "AS IS" basis, WITHOUT WARRENTY OF ANY     *
   * KIND, either impressed or implied.                                         *
   ******************************************************************************/
  class CompilerOutput {
    constructor() {
      this.title = "";
      this.html = "";
      this.sellQuizzes = [];
      this.stackQuizzes = [];
      this.programmingQuizzes = [];
      this.plot2ds = [];
    }

    refresh() {
      for (let q of this.stackQuizzes) {
        q.updateHTML();
        q.refresh();
      }

      for (let p of this.programmingQuizzes) {
        p.updateHTML();
        p.refresh();
      }

      for (let p of this.plot2ds) {
        p.updateHTML();
        p.refresh();
      }
    }

  }
  const template = `
<div id="container" class="container">
    <br/>
    <p class="text-center">
        <span class="display-1">$TITLE$</span>
    </p>
    <p class="text-center lead">
        $LEADTEXT$
    </p>
</div>
<div id="container" class="container">
    <div class="row">
        <div class="col-sm">
            $CONTENT$
        </div>
    </div>
</div>
`;
  class Compiler {
    constructor() {
      this.spellCheck = false;
    }

    compile(input_str, rootCall = true) {
      let co = new CompilerOutput();
      let input = input_str.split("\n");
      let leadtext = "";
      let content = ""; // numbering

      let sec = 1;
      let subsec = 1;
      let subsubsec = 1;
      let definition = 1;
      let eqn = 1;
      let block_types = ["definition", "theorem", "remark", "sell", "stack", "javablock", "plot2d"];
      let unordereditems = [];
      let ordereditems = [];
      let box = "";
      let box_startline = 0;
      let boxtype = "";
      let parsing_box = false;

      for (let i = 0; i < input.length; i++) {
        let x = input[i];

        if (x.startsWith("%")) ; else if (parsing_box && !x.startsWith("---")) {
          let known_type = false;

          if (box.length == 0) {
            for (let type of block_types) {
              if (x.toLowerCase().startsWith(type + ".")) {
                boxtype = type;
                box += x.substring((type + ".").length).trim() + "\n";
                known_type = true;
                break;
              }
            }

            if (!known_type) box += x + "\n";
          } else {
            box += x + "\n";
          }
        } else if (unordereditems.length > 0 && (x.startsWith(" ") || x.startsWith("\t"))) {
          unordereditems[unordereditems.length - 1] += x;
        } else if (unordereditems.length > 0 && !x.startsWith("* ")) {
          content += "<ul>";

          for (let item of unordereditems) content += "<li>" + this.compile_paragraph(item) + "</li>";

          content += "</ul>";
          unordereditems = [];
        } else if (ordereditems.length > 0 && (x.startsWith(" ") || x.startsWith("\t"))) {
          ordereditems[ordereditems.length - 1] += x;
        } else if (ordereditems.length > 0 && !x.startsWith("- ")) {
          content += "<ol>";

          for (let item of ordereditems) content += "<li>" + this.compile_paragraph(item) + "</li>";

          content += "</ol>";
          ordereditems = [];
        } else if (x.startsWith("* ")) {
          unordereditems.push(x.substring(2));
        } else if (x.startsWith("- ")) {
          ordereditems.push(x.substring(2));
        } // centered equation
        else if (x.trim().startsWith("$") && x.length > 1 && (x[0] == " " || x[0] == "\t")) {
          content += `
                <div class="" style="position:relative">
                    <p class="text-center" style="position:absolute;width:100%;">
                        ` + this.compile_paragraph(x.trim()) + `
                    </p>
                    <p class="text-end" style="position:absolute;width:100%;">
                        (\`` + eqn + `\`)
                    </p>
                </div>`;
          content += "<br/>";
          eqn++;
        } else if (x.startsWith("#####")) {
          co.title = x.substring(5).trim();
        } else if (x.startsWith("###")) {
          content += "<a onclick=\"slw.jump(" + i + ");\" style=\"cursor:pointer;\">";
          content += "<h3>" + sec + "." + subsec + "." + subsubsec + ". " + x.substring(3).trim() + "</h3>\n";
          content += "</a>\n";
          subsubsec += 1;
        } else if (x.startsWith("##")) {
          content += "<a onclick=\"slw.jump(" + i + ");\" style=\"cursor:pointer;\">";
          content += "<h2>" + sec + "." + subsec + ". " + x.substring(2).trim() + "</h2>\n";
          content += "</a>\n";
          subsec += 1;
          subsubsec = 1;
        } else if (x.startsWith("#")) {
          content += "<a onclick=\"slw.jump(" + i + ");\" style=\"cursor:pointer;\">";
          content += "<h1>" + sec + ". " + x.substring(1).trim() + "</h1>";
          content += "</a>\n";
          sec += 1;
          subsec = 1;
          subsubsec = 1;
          definition = 1;
        } else if (x.startsWith("---")) {
          parsing_box = !parsing_box;

          if (parsing_box == false) {
            if (boxtype === "sell") {
              let q = new SellQuiz();
              q.id = co.sellQuizzes.length;
              q.src = box;
              co.sellQuizzes.push(q);
              content += "<div id=\"sellquiz-" + q.id + "\"></div>\n";
            } else if (boxtype === "plot2d") {
              let p = new Plot2d();
              p.id = co.plot2ds.length;
              p.title = "";
              p.src = "";
              let lines = box.split("\n");

              for (let i = 0; i < lines.length; i++) {
                if (i == 0) p.title = lines[i];else p.src += lines[i] + "\n";
              }

              co.plot2ds.push(p);
              content += "<div id=\"plot2d-" + p.id + "\"></div>\n";
            } else if (boxtype === "javablock") {
              let parts = this.compile_box_parts(box, ["@text", "@given", "@asserts", "@forbidden-keywords", "@required-keywords", "@solution"]);

              if (parts["error"].length > 0) {
                content += "error: " + parts["error"];
              } else {
                let p = new PorgrammingQuiz();
                p.id = co.programmingQuizzes.length;
                p.title = parts["@title"];
                p.text = this.compile(parts["@text"], false).html;
                p.given = this.removeEmptyLines(parts["@given"]);
                p.asserts = this.removeEmptyLines(parts["@asserts"]).split("\n");
                p.forbiddenKeywords = this.removeEmptyLines(parts["@forbidden-keywords"]).split("\n");
                p.requiredKeywords = this.removeEmptyLines(parts["@required-keywords"]).split("\n");
                p.solution = parts["@solution"];
                co.programmingQuizzes.push(p);
                content += "<div id=\"programming-" + p.id + "\"></div>\n";
              }
            } else if (boxtype === "stack") {
              let q = new StackQuiz();
              q.id = co.stackQuizzes.length;
              co.stackQuizzes.push(q);
              let parts = this.compile_box_parts(box, ["@tags", "@code", "@text", "@solution"]);
              q.error = parts["error"];

              if (q.error.length == 0) {
                q.title = parts["@title"];
                q.taglist = this.compile_tags(parts["@tags"]);
                q.code = parts["@code"];
                q.text = this.compile(parts["@text"], false).html;
                q.solutiontext = this.compile(parts["@solution"], false).html;
                q.code = q.compileCode(q.code);
                q.code += "values;\n";
                q.code += "ev(values);\n";
                q.code += "float(ev(values));\n";
              }

              content += "<div id=\"stackquiz-" + q.id + "\"></div>\n";
            } else {
              content += "<div class=\"card border-dark\">";
              content += "<div class=\"card-body\">\n";
              let box_title = "";
              let no = "";

              if (["definition", "theorem"].includes(boxtype)) {
                no = " " + (sec - 1) + "." + definition;
                definition++;
              }

              if (boxtype.length > 0) {
                box_title = "<a onclick=\"slw.jump(" + box_startline + ");\" style=\"cursor:pointer;\">";
                box_title += "<b>" + text(boxtype) + no + "</b> ";
                box_title += "</a>";
              }

              let y = this.compile(box, false);
              if (y.html.startsWith("<p>")) y.html = "<p>" + box_title + y.html.substring(3);else y.html = box_title + y.html;
              content += y.html;
              content += "</div>\n"; // end of card body

              content += "</div>\n"; // end of card
            }

            box = "";
          } else {
            box_startline = i;
            boxtype = "";
          }
        } else {
          content += "<p>" + this.compile_paragraph(x) + "</p>\n";
        }
      }

      if (rootCall) {
        co.html = template.replaceAll("$TITLE$", co.title);
        co.html = co.html.replaceAll("$LEADTEXT$", leadtext);
        co.html = co.html.replaceAll("$CONTENT$", content);
      } else {
        co.html = content;
      } //console.log(output);


      return co;
    }

    compile_tags(x) {
      let output = [];
      let y = x.replaceAll("\n", " ").split(" ");

      for (let yi of y) {
        if (yi.length > 0) output.push(yi);
      }

      return output;
    }

    compile_paragraph(x) {
      let y = "";
      let is_tex = false;
      let is_bold = false;
      let is_italic = false;
      let is_inlinecode = false;
      let color = "";
      let word = "";
      const n = x.length;

      for (let i = 0; i <= n; i++) {
        let ch = x[i];

        if (word.length > 0 && (i == n || !(ch >= 'A' && ch <= 'Z' || ch >= 'a' && ch <= 'z'))) {
          if (this.spellCheck == false || exports.spellInst.isCorrect(word)) y += word;else y += "<span class=\"border-bottom border-danger\">" + word + "</span>";
          word = "";
        }

        if (i == n) break;

        if (ch === "$") {
          is_tex = !is_tex;
          y += "`";
        } else if (ch === "`") {
          is_inlinecode = !is_inlinecode;
          y += is_inlinecode ? "<code>" : "</code>";
        } else if (!is_inlinecode && !is_tex && ch === "*") {
          is_bold = !is_bold;
          y += is_bold ? "<b>" : "</b>";
        } else if (!is_inlinecode && !is_tex && ch === "_") {
          is_italic = !is_italic;
          y += is_italic ? "<i>" : "</i>";
        } else if (x.substr(i).startsWith("red(")) {
          color = "red";
          y += "<span class=\"text-danger\">";
          i += "red".length;
        } else if (x.substr(i).startsWith("green(")) {
          color = "green";
          y += "<span class=\"text-success\">";
          i += "green".length;
        } else if (x.substr(i).startsWith("blue(")) {
          color = "blue";
          y += "<span class=\"text-primary\">";
          i += "blue".length;
        } else if (color.length > 0 && ch === ")") {
          color = "";
          y += "</span>";
        } else if (!is_tex && !is_inlinecode && (ch >= 'A' && ch <= 'Z' || ch >= 'a' && ch <= 'z')) {
          word += ch;
        } else {
          y += ch;
        }
      } // clean up unclosed scopes


      if (is_tex) y += "`";
      if (is_bold) y += "</b>";
      if (is_italic) y += "</i>";
      if (color.length > 0) y += "</span>";
      return y;
    }

    compile_box_parts(input, ids) {
      let parts = {};
      parts["error"] = "";

      for (let id of ids) parts[id] = "";

      let state = "";
      let lines = input.split("\n");

      for (let i = 0; i < lines.length; i++) {
        let line = lines[i];
        if (i == 0) parts["@title"] = line;
        if (line.trim().length == 0) continue;
        if (line.startsWith("@")) line = line.trim();

        if (ids.includes(line)) {
          state = line;
          parts[state] = "";
        } else if (line.startsWith("@")) {
          parts["error"] = "error: unknown part '" + line + "'";
        } else {
          parts[state] += line + "\n";
        }
      }

      return parts;
    }

    removeEmptyLines(input) {
      let output = "";
      const lines = input.split("\n");
      const n = lines.length;

      for (let i = 0; i < n; i++) {
        if (lines[i].trim().length > 0) {
          if (output.length > 0) output += "\n";
          output += lines[i];
        }
      }

      return output;
    }

  }

  /******************************************************************************
   * SELLQUIZ-LANGUAGE-WORKBENCH                                                *
   *                                                                            *
   * Copyright (c) 2019-2021 TH Köln                                            *
   * Author: Andreas Schwenk, contact@compiler-construction.com                 *
   *                                                                            *
   * Partly funded by: Digitale Hochschule NRW                                  *
   * https://www.dh.nrw/kooperationen/hm4mint.nrw-31                            *
   *                                                                            *
   * GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007                         *
   *                                                                            *
   * This library is licensed as described in LICENSE, which you should have    *
   * received as part of this distribution.                                     *
   *                                                                            *
   * This software is distributed on "AS IS" basis, WITHOUT WARRENTY OF ANY     *
   * KIND, either impressed or implied.                                         *
   ******************************************************************************/
  exports.spellInst = null; // load on demand to reduce traffic to load dictionary

  exports.editor = null;
  exports.compilerOutput = null;
  exports.current_course = '';
  exports.current_file = '';
  var toggle_states = {
    "preview-spell-check": false,
    "preview-show-source-links": true,
    "preview-show-solutions": true,
    "preview-show-variables": true,
    "preview-show-export": true
  };
  function refresh_filelist() {
    let filelist_button = document.getElementById("filelist_button");
    let filelist_dropdown_items = document.getElementById("filelist_dropdown_items");
    $.ajax({
      type: "POST",
      url: "services/filelist.php",
      data: {
        course: exports.current_course
      },
      success: function (data) {
        data = JSON.parse(data);
        if (data["status"] === "error") alert(data["error_message"]); // TODO

        let html = '',
            i = 0;

        for (let file of data["file_list"]) {
          html += '<li><a class="dropdown-item" style="cursor:pointer;">' + file + '</a></li>';
          if (i == 0) exports.current_file = file;
          i++;
        }

        filelist_dropdown_items.innerHTML = html;
        filelist_button.innerHTML = exports.current_file;
      },
      error: function (xhr, status, error) {
        console.error(xhr); // TODO: error handling!
      }
    });
  }
  function refresh_courselist() {
    let courselist_button = document.getElementById("courselist_button");
    let courselist_dropdown_items = document.getElementById("courselist_dropdown_items");
    $.ajax({
      type: "POST",
      url: "services/courselist.php",
      data: {},
      success: function (data) {
        data = JSON.parse(data);
        if (data["status"] === "error") alert(data["error_message"]); // TODO

        let html = '',
            i = 0;

        for (let course of data["course_list"]) {
          html += '<li><a class="dropdown-item" style="cursor:pointer;">' + course + '</a></li>';
          if (i == 0) exports.current_course = course;
          i++;
        }

        courselist_dropdown_items.innerHTML = html;
        courselist_button.innerHTML = exports.current_course;
        refresh_filelist();
      },
      error: function (xhr, status, error) {
        console.error(xhr); // TODO: error handling!
      }
    });
  }
  function init() {
    refresh_courselist(); // init code editor

    /*CodeMirrorSpellChecker({ // TODO: activate / deactivate option
        codeMirrorInstance: CodeMirror,
    });*/

    exports.editor = codemirror__namespace.fromTextArea(document.getElementById("editor"), {
      //mode: "spell-checker",  // TODO: activate / deactivate option
      mode: "sellquiz-edit",
      lineNumbers: true,
      lineWrapping: true,
      styleActiveLine: {
        nonEmpty: true
      },
      extraKeys: {
        "Ctrl-S": function (cm) {
          save();
        },
        "Cmd-S": function (cm) {
          save();
        },
        "Ctrl-F": function (cm) {
          alert("searching text is unimplemented!");
        },
        "Cmd-F": function (cm) {
          alert("searching text is unimplemented!");
        },
        "F1": function (cm) {
          update();
        },
        "F2": function (cm) {
          document.getElementById("insertCodeButton").click();
        }
      }
    });
    exports.editor.setSize(null, "100%"); // populate math symbols

    let html = "<table class=\"p-1\">";
    let symbols = ['sum', 'prod', 'xx', '@', 'o+', 'ox', 'o.', '^^', '^^^', 'vv', 'vvv', 'nn', 'nnn', 'uu', 'uuu', 'a/b', 'a^b', 'sqrt(x)', 'root(x)(y)', 'int', 'oint', 'del', 'grad', '+-', 'O/', 'oo', 'aleph', 'abs(x)', 'floor(x)', 'ceil(x)', 'norm(vecx)', '/_', '/_\\', 'diamond', 'square', 'CC', 'NN', 'QQ', 'RR', 'ZZ', '"text"', '!=', '<', '>', '<=', '>=', '-<', '-<=', '>-', '>-=', 'in', 'notin', 'sub', 'sup', 'sube', 'supe', '-=', '~=', '~~', 'prop', 'neg', '=>', '<=>', 'AA', 'EE', '_|_', 'TT', '|--', '|==', '{', '}', '(:', ':)', '<<', '>>', 'uarr', 'darr', '->', '>->', '->>', '>->>', '|->', 'larr', 'harr', 'rArr', 'lArr', 'hArr', 'hat x', 'bar x', 'ul x', 'vec x', 'tilde x', 'dot x', 'ddot x', 'overset(x)(=)', 'underset(x)(=)', 'ubrace(x)', 'obrace(x)', 'color(red)(x)', 'cancel(x)', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'varepsilon', 'zeta', 'eta', 'theta', 'vartheta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'pi', 'rho', 'sigma', 'tau', 'upsilon', 'phi', 'varphi', 'chi', 'psi', 'omega', 'bb "Aa"', 'bbb "Aa"', 'cc "Aa"', 'tt "Aa"', 'fr "Aa"', 'sf "Aa"', '[[a,b],[c,d]]', '((a),(b))', '[[a,b,|,c],[d,e,|,f]]', 'lim_(n->oo) sum_(i=0)^n', 'int_0^1 f(x) \ dx', 'f\'(x)=dy/dx'];
    const cols = 16;
    const rows = Math.ceil(symbols.length / cols);

    for (let i = 0; i < rows; i++) {
      html += "<tr>";

      for (let j = 0; j < cols; j++) {
        let idx = i * cols + j;

        if (idx < symbols.length) {
          let onclick = "slw.insertCode(' " + symbols[idx] + " ');slw.editor.focus();";
          html += "<td class=\"border border-dark p-1 text-center\" style=\"cursor:pointer;\"><a onclick=\"" + onclick + "\"> ` " + symbols[idx] + " ` </a></td>";
        } else html += "<td></td>";
      }

      html += "</tr>";
    }

    html += "</table>";
    document.getElementById("math-symbols").innerHTML = html; // populate code templates

    let code_templates = ["Document Title", "\n##### My Title\n", "Section", "\n# My Section\n", "Subsection", "\n## My Subsection\n", "Subsubsection", "\n### My Subsubsection\n", "Definition", "\n---\nDefinition.\n---\n\n", "Theorem", "\n---\nTheorem.\n---\n\n", "SELL-Quiz", "\n---\nSell. My Quiz\n\tx, y in {1,2,3}\n\\tz := x + y\n$ x + y = #z $\n---\n\n", "STACK-Quiz", "\n---\nStack. My Quiz\n\n@code\nx:random(10)\ny:random(10)\nz:x+y;\n\n@text\n$x+y=#z$\n\n@solution\nJust add both numbers!\n---\n\n"];
    html = '';

    for (let i = 0; i < code_templates.length / 2; i++) {
      let id = code_templates[i * 2 + 0];
      let code = code_templates[i * 2 + 1].replaceAll("\n", "\\n").replaceAll("\t", "\\t");
      html += `<a class="list-group-item list-group-item-action"
                    onclick="slw.insertCode('` + code + `');"
                    style="cursor:pointer;"
                    >` + id + `</a>`;
    }

    document.getElementById("insertCodeList").innerHTML = html; // read demo file: TODO: move code!!!!!

    $.ajax({
      type: "POST",
      url: "services/read.php",
      data: {
        course: "demo",
        file: "demo" // TODO

      },
      success: function (data) {
        data = JSON.parse(data);
        if (data["status"] === "error") alert(data["error_message"]); // TODO

        exports.editor.setValue(data["content"]);
        update();
      },
      error: function (xhr, status, error) {
        console.error(xhr); // TODO: error handling!
      }
    });
  }
  function jump(lineNo) {
    exports.editor.scrollTo(null, exports.editor.charCoords({
      line: lineNo,
      ch: 0
    }, "local").top);
  }
  function insertCode(text) {
    var doc = exports.editor.getDoc();
    var cursor = doc.getCursor();
    doc.replaceRange(text, cursor);
  }
  function undo() {
    exports.editor.undo();
  }
  function redo() {
    exports.editor.redo();
  }
  function save() {
    alert("unimplemented");
  }
  function update() {
    let compiler = new Compiler();
    compiler.spellCheck = toggle_states["preview-spell-check"];
    exports.compilerOutput = compiler.compile(exports.editor.getValue());
    document.getElementById("rendered-content").innerHTML = exports.compilerOutput.html;
    exports.compilerOutput.refresh(); // refresh SELL-quizzes -> TODO: move code to quiz.ts

    sellquiz__namespace.reset();
    sellquiz__namespace.setLanguage(language); //sellquiz.setServicePath(TODO);

    const n = exports.compilerOutput.sellQuizzes.length;

    for (let i = 0; i < n; i++) {
      let domElement = document.getElementById("sellquiz-" + i);
      let qIdx = sellquiz__namespace.createQuestion(exports.compilerOutput.sellQuizzes[i].src);
      sellquiz__namespace.setQuestionHtmlElement(qIdx, domElement);

      if (qIdx < 0) {
        let err = sellquiz__namespace.getErrorLog().replaceAll("\n", "<br/>");
        let html = '<div class="card border-dark"><div class="card-body">';
        html += '<p class="text-danger"><b>' + err + '</b></p>';
        html += '</div></div>';
        domElement.innerHTML = html;
      } else {
        let quizHtml = sellquiz__namespace.getQuestionHighLevelHTML(qIdx);
        domElement.innerHTML = quizHtml;
        sellquiz__namespace.refreshQuestion(qIdx);
      }
    }

    eval("typeset()");
  }
  function eval_prog(idx) {
    if (exports.compilerOutput == null) return;
    exports.compilerOutput.programmingQuizzes[idx].evaluate();
  }
  function eval_stack(idx) {
    if (exports.compilerOutput == null) return;
    exports.compilerOutput.stackQuizzes[idx].evaluate();
  }
  function export_stack(idx) {
    if (exports.compilerOutput == null) return;
    exports.compilerOutput.stackQuizzes[idx].exportMoodleXML();
  }
  function toggle(buttonName) {
    let element = document.getElementById(buttonName);
    toggle_states[buttonName] = !toggle_states[buttonName];
    if (toggle_states[buttonName]) element.className = "btn btn-dark mx-0 btn-sm";else element.className = "btn btn-outline-dark mx-0 btn-sm";

    if (buttonName == "preview-spell-check") {
      if (exports.spellInst == null) {
        exports.spellInst = new Spell();
      } else update();
    }
  }

  exports.eval_prog = eval_prog;
  exports.eval_stack = eval_stack;
  exports.export_stack = export_stack;
  exports.init = init;
  exports.insertCode = insertCode;
  exports.jump = jump;
  exports.redo = redo;
  exports.refresh_courselist = refresh_courselist;
  exports.refresh_filelist = refresh_filelist;
  exports.save = save;
  exports.toggle = toggle;
  exports.toggle_states = toggle_states;
  exports.undo = undo;
  exports.update = update;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({}, CodeMirror, sellquiz, nspell);
