var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/compiler/index.ts
var import_fs4 = __toESM(require("fs"));
var import_process = __toESM(require("process"));

// src/compiler/image.ts
var import_fs2 = __toESM(require("fs"));
var import_child_process = require("child_process");

// src/compiler/help.ts
var import_os = __toESM(require("os"));
var import_path = __toESM(require("path"));
var import_fs = __toESM(require("fs"));
function makeTempDirectory() {
  const tmp = import_os.default.tmpdir() + import_path.default.sep + "sellquiz-language-workbench" + import_path.default.sep + Math.floor(Math.random() * 1e15).toString() + import_path.default.sep;
  import_fs.default.mkdirSync(tmp, { recursive: true });
  return tmp;
}
function deleteTempDirectory(dir) {
  import_fs.default.rmSync(dir, {
    recursive: true,
    force: true
  });
}

// src/compiler/part.ts
var Part = class {
  constructor(inputLineNo) {
    this.id = "";
    this.src = "";
    this.type = "unknown" /* unknown */;
    this.text = "";
    this.error = false;
    this.labeledText = {};
    this.inputLineNo = 0;
    this.question = null;
    this.image = null;
    this.inputLineNo = inputLineNo;
  }
  toJson() {
    const j = {};
    j.type = this.type;
    j.inputLineNo = this.inputLineNo;
    j.text = this.text;
    j.error = this.error;
    j.src = this.src;
    if (this.question != null)
      this.question.toJson(j);
    if (this.image != null)
      this.image.toJson(j);
    return j;
  }
};

// src/compiler/strings.ts
var TIKZ_PROG = `
\\documentclass[class=minimal,border=0pt]{standalone}
\\usepackage[latin1]{inputenc}
\\usepackage{tikz}
\\begin{document}
\\pagestyle{empty}
\\begin{tikzpicture}
$CODE$
\\end{tikzpicture}
\\end{document}
`;
var PYTHON_PROG = `
import math
import numpy
import random
_import_names = ['math', 'numpy', 'random']

__s = ''
_vars = [];
for __i in range(0, $INSTANCES$):

$CODE$

    if __i == 0:
        _vars=dir()
    _ids=[]
    _types=[]
    _values=[]
    for v in _vars:
        if v.startswith('_') or v.startswith('__'):
            continue
        if v in _import_names:
            continue
        value = eval(v)
        if isinstance(value, numpy.matrix):
            value = numpy.array2string(A, separator=',').replace('\\n','')
            _ids.append(v)
            _types.append('matrix')
            _values.append(value)
        elif isinstance(value, int):
            _ids.append(v)
            _types.append('int')
            _values.append(value)
        elif isinstance(value, float):
            _ids.append(v)
            _types.append('float')
            _values.append(value)
        elif isinstance(value, complex):
            _ids.append(v)
            _types.append('complex')
            c = str(value)
            c.replace('j', 'i')
            if c.startswith('('):
                c = c[1:-1]
            _values.append(c)
        else:
            _ids.append(v)
            _types.append('unknown')
            _values.append(value)

    if __i == 0:
        for id in _ids:
            __s += id + '#'
        __s += '\\n'
        for type in _types:
            __s += type + '#'
        __s += '\\n'

    for value in _values:
        __s += str(value) + '#'
    __s += '\\n'

print(__s)
`;

// src/compiler/image.ts
var Image = class {
  constructor() {
    this.dataBase64 = "";
  }
  compileImage(part) {
    part.type = "image" /* image */;
    const tmpDir = makeTempDirectory();
    let res = "";
    const code = part.labeledText[""];
    const prog = TIKZ_PROG.replace("$CODE$", code);
    import_fs2.default.writeFileSync(tmpDir + "image.tex", prog);
    try {
      res = (0, import_child_process.execSync)("cd " + tmpDir + " && pdflatex -halt-on-error --enable-pipes --shell-escape " + tmpDir + "image.tex", {
        encoding: "utf-8",
        timeout: 1e4,
        stdio: "pipe"
      });
    } catch (e) {
      part.error = true;
      part.text = e["stderr"];
      console.log(part.text);
    }
    if (part.error == false) {
      try {
        res = (0, import_child_process.execSync)("pdf2svg " + tmpDir + "image.pdf " + tmpDir + "image.svg", {
          encoding: "utf-8",
          timeout: 1e4,
          stdio: "pipe"
        });
      } catch (e) {
        part.error = true;
        part.text = e["stderr"];
        console.log(part.text);
      }
    }
    if (part.error == false) {
      this.dataBase64 = "data:image/svg+xml;base64," + import_fs2.default.readFileSync(tmpDir + "image.svg", "base64");
    }
    deleteTempDirectory(tmpDir);
  }
  toJson(json) {
    json["data"] = this.dataBase64;
  }
};

// src/compiler/question.ts
var import_fs3 = __toESM(require("fs"));
var import_child_process2 = require("child_process");
var Question = class {
  constructor() {
    this.variableIDs = [];
    this.variableTypes = [];
    this.variableValues = [];
    this.inputFieldTypes = [];
    this.inputFieldAnswers = [];
    this.text = "";
    this.solutionText = "";
  }
  compileQuestion(part) {
    part.type = "question" /* question */;
    if ("text" in part.labeledText)
      this.text = part.labeledText["text"];
    if ("solution" in part.labeledText)
      this.solutionText = part.labeledText["solution"];
    if ("python" in part.labeledText) {
      const tmpDir = makeTempDirectory();
      let res = "";
      const code = "    " + part.labeledText["python"].replace(/\n/g, "\n    ");
      const prog = PYTHON_PROG.replace("$CODE$", code).replace("$INSTANCES$", "5");
      import_fs3.default.writeFileSync(tmpDir + "sell.py", prog);
      try {
        res = (0, import_child_process2.execSync)("python3 " + tmpDir + "sell.py", {
          encoding: "utf-8",
          timeout: 1e4,
          stdio: "pipe"
        });
      } catch (e) {
        part.error = true;
        part.text = e["stderr"];
        console.log(part.text);
      }
      deleteTempDirectory(tmpDir);
      if (part.error == false) {
        const lines = res.split("\n");
        this.variableIDs = lines[0].split("#");
        this.variableIDs.pop();
        this.variableTypes = lines[1].split("#");
        this.variableTypes.pop();
        for (let j = 2; j < lines.length; j++) {
          if (lines[j].trim().length == 0)
            continue;
          const values = lines[j].split("#");
          values.pop();
          this.variableValues.push(values);
        }
      }
    }
    this.text = this.compileText(this.text, true);
    this.solutionText = this.compileText(this.solutionText);
  }
  compileText(text, generateInputFields = false) {
    let res = "";
    const n = text.length;
    let id = "";
    let inMath = false;
    let hashtag = false;
    text = text + " ";
    for (let i = 0; i < n; i++) {
      const ch = text[i];
      if (id.length == 0 && (ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z")) {
        id += ch;
      } else if (id.length > 0 && (ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch >= "0" && ch <= "9")) {
        id += ch;
      } else {
        if (generateInputFields && !inMath && hashtag && id.length > 0 && this.variableIDs.includes(id)) {
          res += "?" + this.inputFieldAnswers.length + "?";
          this.inputFieldAnswers.push(id);
          let type = this.variableTypes[this.variableIDs.indexOf(id)];
          if (type === "complex")
            type = "complex-normalform";
          this.inputFieldTypes.push(type);
        } else if (inMath && id.length > 0 && this.variableIDs.includes(id)) {
          res += "@" + id + "@";
        } else if (id.length > 0) {
          res += id;
        }
        if (ch === "$")
          inMath = !inMath;
        hashtag = inMath == false && ch === "#";
        id = "";
        if (!hashtag)
          res += ch;
      }
    }
    return res;
  }
  toJson(json) {
    json["text"] = this.text;
    json["solution"] = this.solutionText;
    json["variable-ids"] = this.variableIDs;
    json["variable-types"] = this.variableTypes;
    json["variable-values"] = this.variableValues;
    json["input-field-types"] = this.inputFieldTypes;
    json["input-field-answers"] = this.inputFieldAnswers;
  }
};

// src/compiler/document.ts
var Document = class {
  constructor() {
    this.type = "course-page";
    this.isAsciiMath = true;
    this.title = "";
    this.tags = [];
    this.parts = [];
    this.section = 1;
    this.subsection = 2;
    this.susubsection = 3;
    this.forceNewParagraph = false;
  }
  compile(input2) {
    const lines = input2.split("\n");
    const n = lines.length;
    for (let lineIdx = 0; lineIdx < n; lineIdx++) {
      let line = lines[lineIdx];
      if (line.trim().startsWith("%"))
        continue;
      if (line.trim().length == 0) {
        this.forceNewParagraph = true;
      } else if (line.startsWith("##### ")) {
        this.title = line.substring(6).trim();
      } else if (line.startsWith("=====")) {
        const part = new Part(lineIdx + 1);
        this.parts.push(part);
        part.type = "new-page" /* newPage */;
      } else if (line.startsWith("!")) {
        if (line.startsWith("!tex"))
          this.isAsciiMath = false;
      } else if (line.startsWith("# ")) {
        const part = new Part(lineIdx + 1);
        this.parts.push(part);
        part.type = "headline-1" /* headline1 */;
        part.text = this.section + ". " + line.substring(2).trim();
        this.section++;
        this.subsection = 1;
        this.susubsection = 1;
      } else if (line.startsWith("## ")) {
        const part = new Part(lineIdx + 1);
        this.parts.push(part);
        part.type = "headline-1" /* headline1 */;
        part.text = this.section + "." + this.subsection + " " + line.substring(2).trim();
        this.subsection++;
        this.susubsection = 1;
      } else if (line.startsWith("### ")) {
        const part = new Part(lineIdx + 1);
        this.parts.push(part);
        part.type = "headline-1" /* headline1 */;
        part.text = this.section + "." + this.subsection + "." + this.susubsection + " " + line.substring(2).trim();
        this.susubsection++;
      } else if (line.startsWith("---")) {
        const part = new Part(lineIdx + 1);
        this.parts.push(part);
        part.type = "uncompiled-block" /* uncompiledBlock */;
        let textId = "";
        lineIdx++;
        let first = true;
        while (lineIdx < n) {
          line = lines[lineIdx];
          part.src += line + "\n";
          if (first) {
            part.id = line.trim();
          }
          if (line.startsWith("---")) {
            break;
          } else if (line.startsWith("@")) {
            textId = line.substring(1).trim();
          } else if (!first) {
            if (textId in part.labeledText == false)
              part.labeledText[textId] = line + "\n";
            else
              part.labeledText[textId] += line + "\n";
          }
          if (first)
            first = false;
          lineIdx++;
        }
      } else {
        let part = null;
        if (!this.forceNewParagraph && this.parts.length > 0 && this.parts.slice(-1)[0].type == "paragraph" /* paragraph */) {
          part = this.parts.slice(-1)[0];
        } else {
          part = new Part(lineIdx + 1);
          part.type = "paragraph" /* paragraph */;
          this.parts.push(part);
        }
        part.text += line + "\n";
        this.forceNewParagraph = false;
      }
    }
    for (const part of this.parts) {
      switch (part.type) {
        case "paragraph" /* paragraph */:
          part.text = this.compileParagraph(part.text);
          break;
        case "uncompiled-block" /* uncompiledBlock */:
          if (part.id === "Definition.")
            this.compileDefinition(part);
          else if (part.id === "Example.")
            this.compileExample(part);
          else if (part.id === "Question.") {
            part.question = new Question();
            part.question.compileQuestion(part);
            part.question.text = this.compileParagraph(part.question.text);
            part.question.solutionText = this.compileParagraph(part.question.solutionText);
          } else if (part.id === "Tikz.") {
            part.image = new Image();
            part.image.compileImage(part);
          } else {
            part.type = "error" /* error */;
            part.text = "error: unknown part type '" + part.id + "'";
          }
          break;
      }
    }
    return JSON.stringify(this.toJson(), null, 4);
  }
  compileDefinition(part) {
    part.type = "definition" /* definition */;
    part.text = this.compileParagraph(part.labeledText[""]);
  }
  compileExample(part) {
    part.type = "example" /* example */;
    part.text = this.compileParagraph(part.labeledText[""]);
  }
  compileParagraph(text) {
    let res = "";
    const n = text.length;
    let isBold = false;
    let isItalic = false;
    let isList = false;
    let isListItem = false;
    let col = 0;
    for (let i = 0; i < n; i++) {
      const ch = text[i];
      if (col == 0 && ch === "-") {
        if (isListItem)
          res += "</li>";
        if (!isList)
          res += "<ul>";
        isList = true;
        isListItem = true;
        res += "<li>";
        col++;
        continue;
      } else if (col == 0 && isList) {
        if (ch === " " || ch === "	") {
          res += "<br/>";
        } else {
          isListItem = false;
          isList = false;
          res += "</li></ul>";
        }
      }
      if (ch === "$") {
        let eqn = "";
        for (let j = i + 1; j < n; j++) {
          const ch2 = text[j];
          if (ch2 == "$") {
            i = j;
            break;
          }
          eqn += ch2;
        }
        res += "\\(" + eqn + "\\)";
      } else if (ch === "*") {
        if (text.substring(i).startsWith("**")) {
          i++;
          isBold = !isBold;
          res += isBold ? "<b>" : "</b>";
        } else {
          isItalic = !isItalic;
          res += isItalic ? "<i>" : "</i>";
        }
      } else if (ch === "\n") {
        col = -1;
      } else {
        res += ch;
      }
      col++;
    }
    if (isBold)
      res += "</b>";
    if (isItalic)
      res += "</i>";
    if (isList)
      res += "</li></ul>";
    return res;
  }
  toJson() {
    const j = {};
    j.type = this.type;
    j.title = this.title;
    j.tags = this.tags;
    j.parts = [];
    for (const part of this.parts) {
      j.parts.push(part.toJson());
    }
    return j;
  }
};

// src/compiler/index.ts
if (import_process.default.argv.length != 4) {
  console.error("Error: usage: node compiler.ts INPUT_FILE_PATH OUTPUT_FILE_PATH");
  import_process.default.exit(-1);
}
var inputFilePath = import_process.default.argv[2];
var outputFilePath = import_process.default.argv[3];
if (import_fs4.default.existsSync(inputFilePath) == false) {
  console.error("error: input file " + inputFilePath + " does not exist");
  import_process.default.exit(-1);
}
console.log("converting " + inputFilePath + " to " + outputFilePath);
var doc = new Document();
var input = import_fs4.default.readFileSync(inputFilePath, "utf-8");
var output = doc.compile(input);
console.log("----- output -----");
console.log(output);
import_fs4.default.writeFileSync(outputFilePath, output);
