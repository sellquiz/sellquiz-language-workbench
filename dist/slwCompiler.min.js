var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/compiler/index.ts
var import_fs4 = __toESM(require("fs"));
var import_process = __toESM(require("process"));

// src/compiler/image.ts
var import_fs2 = __toESM(require("fs"));
var import_child_process = require("child_process");

// src/compiler/help.ts
var import_path = __toESM(require("path"));
var import_fs = __toESM(require("fs"));
function makeTempDirectory() {
  const tmp = "cache/" + Math.floor(Math.random() * 1e15).toString() + import_path.default.sep;
  import_fs.default.mkdirSync(tmp, { recursive: true });
  return tmp;
}
function deleteTempDirectory(dir) {
  import_fs.default.rmSync(dir, {
    recursive: true,
    force: true
  });
}

// src/compiler/part.ts
var Part = class {
  constructor(inputLineNo) {
    this.id = "";
    this.title = "";
    this.src = "";
    this.type = "unknown" /* unknown */;
    this.text = "";
    this.error = false;
    this.errorLog = "";
    this.labeledText = {};
    this.inputLineNo = 0;
    this.question = null;
    this.programmingQuestion = null;
    this.image = null;
    this.authentication = null;
    this.oldJson = null;
    this.inputLineNo = inputLineNo;
  }
  toJson() {
    if (this.oldJson != null)
      return this.oldJson;
    const j = {};
    j.type = this.type;
    j.inputLineNo = this.inputLineNo;
    j.text = this.text;
    j.title = this.title;
    j.error = this.error;
    j.errorLog = this.errorLog;
    j.src = this.src;
    if (this.question != null)
      this.question.toJson(j);
    if (this.programmingQuestion != null)
      this.programmingQuestion.toJson(j);
    if (this.image != null)
      this.image.toJson(j);
    if (this.authentication != null)
      this.authentication.toJson(j);
    return j;
  }
};

// src/compiler/strings.ts
var TIKZ_PROG = `
\\documentclass[class=minimal,border=0pt]{standalone}
\\usepackage[latin1]{inputenc}
\\usepackage{tikz}
\\begin{document}
\\pagestyle{empty}
\\begin{tikzpicture}
$CODE$
\\end{tikzpicture}
\\end{document}
`;
var PYTHON_PROG = `
import math
import numpy
import random
_import_names = ['math', 'numpy', 'random']

__s = ''
_vars = [];
for __i in range(0, $INSTANCES$):

$CODE$

    if __i == 0:
        _vars=dir()
    _ids=[]
    _types=[]
    _values=[]
    for v in _vars:
        if v.startswith('_') or v.startswith('__'):
            continue
        if v in _import_names:
            continue
        value = eval(v)
        if isinstance(value, numpy.matrix):
            value = numpy.array2string(A, separator=',').replace('\\n','')
            _ids.append(v)
            _types.append('matrix')
            _values.append(value)
        elif isinstance(value, int):
            _ids.append(v)
            _types.append('int')
            _values.append(value)
        elif isinstance(value, float):
            _ids.append(v)
            _types.append('float')
            _values.append(value)
        elif isinstance(value, complex):
            _ids.append(v)
            _types.append('complex')
            c = str(value)
            c = c.replace('j', 'i')
            if c.startswith('('):
                c = c[1:-1]
            _values.append(c)
        else:
            _ids.append(v)
            _types.append('unknown')
            _values.append(value)

    if __i == 0:
        for id in _ids:
            __s += id + '#'
        __s += '\\n'
        for _t in _types:
            __s += _t + '#'
        __s += '\\n'

    for value in _values:
        __s += str(value) + '#'
    __s += '\\n'

print(__s)
`;
var SAGE_PROG = `__s = ''
_vars = []
_ignore = ['In', 'Out', 'exit', 'get_ipython', 'quit']
for __i in range(0, $INSTANCES$):

$CODE$

    if __i == 0:
        _vars=show_identifiers()
    _ids=[]
    _types=[]
    _values=[]
    for v in _vars:
        if v.startswith('_') or v.startswith('__') or v in _ignore:
            continue
        value = eval(v)
        if type(value) == Integer or type(value) == int or type(value) == sage.rings.finite_rings.integer_mod.IntegerMod_int:
            _ids.append(v)
            _types.append('int')
            _values.append(value)
        else:
            _ids.append(v)
            _types.append('unknown')
            _values.append(value)

    if __i == 0:
        for id in _ids:
            __s += id + '#'
        __s += '\\n'
        for _t in _types:
            __s += _t + '#'
        __s += '\\n'

    for value in _values:
        __s += str(value) + '#'
    __s += '\\n'

print(__s)
`;
var OCTAVE_PROG = `
$CODE$

%a=3;
%b=5;
%A=a*[1 2; 3 4];

% TODO: complex numbers!
% TODO: multiple instances!

_vars = who;

_ids = '';
_types = '';
_values = '';
for k=1:length(_vars)
	_ids = strcat(_ids, _vars{k}, '#');
	_value = eval(_vars{k});
	if rows(_value)==1 && columns(_value)==1
		_types = strcat(_types, 'float', '#');
	else
		_types = strcat(_types, 'matrix', '#');
	end
	_values = strcat(_values, mat2str(_value), '#');
end

disp(_ids)
disp(_types)
disp(_values)
`;

// src/compiler/image.ts
var Image = class {
  constructor() {
    this.dataBase64 = "";
  }
  compileImage(part) {
    part.type = "image" /* image */;
    const tmpDir = makeTempDirectory();
    let res = "";
    const code = part.labeledText[""];
    const prog = TIKZ_PROG.replace("$CODE$", code);
    import_fs2.default.writeFileSync(tmpDir + "image.tex", prog);
    try {
      res = (0, import_child_process.execSync)("cd " + tmpDir + " && pdflatex -halt-on-error --enable-pipes --shell-escape " + tmpDir + "image.tex", {
        encoding: "utf-8",
        timeout: 1e4,
        stdio: "pipe"
      });
    } catch (e) {
      part.error = true;
      part.text = e["stderr"];
      console.log(part.text);
    }
    if (part.error == false) {
      try {
        res = (0, import_child_process.execSync)("pdf2svg " + tmpDir + "image.pdf " + tmpDir + "image.svg", {
          encoding: "utf-8",
          timeout: 1e4,
          stdio: "pipe"
        });
      } catch (e) {
        part.error = true;
        part.text = e["stderr"];
        console.log(part.text);
      }
    }
    if (part.error == false) {
      this.dataBase64 = "data:image/svg+xml;base64," + import_fs2.default.readFileSync(tmpDir + "image.svg", "base64");
    }
    deleteTempDirectory(tmpDir);
  }
  toJson(json) {
    json["data"] = this.dataBase64;
  }
};

// src/compiler/question.ts
var import_fs3 = __toESM(require("fs"));
var import_child_process2 = require("child_process");
var Question = class {
  constructor() {
    this.numberOfInstances = 0;
    this.multipleChoiceTexts = [];
    this.multipleChoiceAnswers = [];
    this.variableIDs = [];
    this.variableTypes = [];
    this.variableValues = [];
    this.variableTexts = [];
    this.inputFieldTypes = [];
    this.inputFieldAnswers = [];
    this.text = "";
    this.solutionText = "";
  }
  compileQuestion(part, numberOfInstances) {
    this.numberOfInstances = numberOfInstances;
    part.type = "question" /* question */;
    if ("text" in part.labeledText) {
      this.text = part.labeledText["text"];
    }
    if ("solution" in part.labeledText) {
      this.solutionText = part.labeledText["solution"];
    }
    if ("python" in part.labeledText || "sage" in part.labeledText || "octave" in part.labeledText) {
      let command = "", filename = "", template = "", code = "";
      if ("python" in part.labeledText) {
        command = "python3";
        filename = "sell.py";
        template = PYTHON_PROG;
        code = part.labeledText["python"];
        code = "    " + code.replace(/\n/g, "\n    ");
      } else if ("sage" in part.labeledText) {
        command = "sage";
        filename = "sell.sage";
        template = SAGE_PROG;
        code = part.labeledText["sage"];
        code = "    " + code.replace(/\n/g, "\n    ");
      } else {
        command = "octave";
        filename = "sell.m";
        template = OCTAVE_PROG;
        code = part.labeledText["octave"];
      }
      const tmpDir = makeTempDirectory();
      let res = "";
      const prog = template.replace("$CODE$", code).replace("$INSTANCES$", "" + numberOfInstances);
      import_fs3.default.writeFileSync(tmpDir + filename, prog);
      let cmd = "";
      try {
        cmd = "cd " + tmpDir + " && " + command + " " + filename;
        res = (0, import_child_process2.execSync)(cmd, {
          encoding: "utf-8",
          timeout: 1e4,
          stdio: "pipe"
        });
      } catch (e) {
        part.error = true;
        part.errorLog = e["stderr"] + "--- command: " + cmd;
        console.log(part.text);
      }
      deleteTempDirectory(tmpDir);
      if (part.error == false) {
        const lines = res.split("\n");
        this.variableIDs = lines[0].split("#");
        this.variableIDs.pop();
        this.variableTypes = lines[1].split("#");
        this.variableTypes.pop();
        for (let j = 2; j < lines.length; j++) {
          if (lines[j].trim().length == 0)
            continue;
          const values = lines[j].split("#");
          values.pop();
          this.variableValues.push(values);
        }
        for (let i = 0; i < this.variableIDs.length; i++) {
          this.variableTexts.push("");
        }
      }
    }
    this.text = this.compileText(this.text, true);
    this.solutionText = this.compileText(this.solutionText);
  }
  compileText(text, generateInputFields = false) {
    if (generateInputFields) {
      let processed = "";
      const lines = text.split("\n");
      let placedMultipleChoiceBlock = false;
      for (let line of lines) {
        const tmp = line.trim().replace(/ /g, "").replace(/\t/g, "");
        if (tmp.startsWith("[]") || tmp.startsWith("[x]") || tmp.startsWith("()") || tmp.startsWith("(x)")) {
          let i = 0;
          while (i < line.length) {
            if (line[i] == "]" || line[i] == ")")
              break;
            i++;
          }
          line = line.substring(i + 1).trim();
          this.multipleChoiceTexts.push(line);
          if (placedMultipleChoiceBlock == false) {
            processed += "?mc?";
            placedMultipleChoiceBlock = true;
          }
          if (tmp.startsWith("[]") || tmp.startsWith("()")) {
            this.multipleChoiceAnswers.push(false);
          } else if (tmp.startsWith("[x]") || tmp.startsWith("(x)")) {
            this.multipleChoiceAnswers.push(true);
          }
        } else {
          processed += line + "\n";
        }
      }
      text = processed;
      if (this.variableValues.length == 0) {
        for (let k = 0; k < this.numberOfInstances; k++)
          this.variableValues.push([]);
      }
      for (let i = 0; i < this.multipleChoiceAnswers.length; i++) {
        this.variableIDs.push("mc__" + i);
        this.variableTypes.push("bool");
        this.variableTexts.push(this.compileText(this.multipleChoiceTexts[i], false));
        this.inputFieldTypes.push("check-box");
        this.inputFieldAnswers.push("mc__" + i);
        for (let k = 0; k < this.numberOfInstances; k++) {
          this.variableValues[k].push(this.multipleChoiceAnswers[i] ? "true" : "false");
        }
      }
    }
    let res = "";
    const n = text.length;
    let inMath = false;
    let hashtag = false;
    const tokens = [];
    let token = "";
    for (let i = 0; i < n; i++) {
      const ch = text[i];
      if (token.length == 0 && (ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z")) {
        token += ch;
      } else if (token.length > 0 && (ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch >= "0" && ch <= "9")) {
        token += ch;
      } else if (ch === '"') {
        if (token.length > 0) {
          tokens.push(token);
          token = "";
        }
        token += '"';
        i++;
        while (i < n && text[i] !== '"') {
          token += text[i];
          i++;
        }
        if (i < n && text[i] === '"') {
          token += '"';
          i++;
        }
        i--;
      } else {
        if (token.length > 0) {
          tokens.push(token);
          token = "";
        }
        tokens.push(ch);
      }
    }
    if (token.length > 0)
      tokens.push(token);
    for (token of tokens) {
      if (generateInputFields && inMath == false && hashtag && this.variableIDs.includes(token)) {
        res += "?" + this.inputFieldAnswers.length + "?";
        this.inputFieldAnswers.push(token);
        let type = this.variableTypes[this.variableIDs.indexOf(token)];
        if (type === "int")
          type = "text-field";
        else if (type === "float")
          type = "text-field";
        else if (type === "complex")
          type = "complex-normalform";
        this.inputFieldTypes.push(type);
      } else if (token === "$") {
        inMath = !inMath;
        res += "$";
      } else if (inMath && this.variableIDs.includes(token)) {
        res += "@" + token + "@";
      } else if (inMath && token.startsWith('"') && token.endsWith('"')) {
        res += token.substring(1, token.length - 1);
      } else if (token === "#") {
        hashtag = true;
      } else {
        res += token;
        hashtag = false;
      }
    }
    return res;
  }
  toJson(json) {
    json["text"] = this.text;
    json["solution"] = this.solutionText;
    json["variable-ids"] = this.variableIDs;
    json["variable-types"] = this.variableTypes;
    json["variable-values"] = this.variableValues;
    json["variable-texts"] = this.variableTexts;
    json["input-field-types"] = this.inputFieldTypes;
    json["input-field-answers"] = this.inputFieldAnswers;
  }
};

// src/compiler/programmingQuestion.ts
var ProgrammingQuestion = class {
  constructor() {
    this.type = "JavaProgram" /* JavaProgram */;
    this.text = "";
    this.solutionText = "";
  }
  compileProgrammingQuestion(part, type) {
    part.type = "programming-question" /* programmingQuestion */;
    this.type = type;
    if ("text" in part.labeledText) {
      this.text = part.labeledText["text"];
    }
    if ("solution" in part.labeledText) {
      this.solutionText = part.labeledText["solution"];
    }
  }
  toJson(json) {
    json["programming-type"] = this.type;
    json["text"] = this.text;
    json["solution"] = this.solutionText;
  }
};

// src/compiler/authentication.ts
var Authentication = class {
  constructor() {
    this.database = "";
    this.requireMatriculationNumber = false;
    this.requireAccessToken = false;
  }
  compileAuthentication(part) {
    part.type = "authentication" /* authentication */;
    if ("database" in part.labeledText == false) {
      part.error = true;
      part.errorLog += "missing @database\n";
      return;
    }
    this.database = part.labeledText["database"].trim();
    if ("input" in part.labeledText) {
      const lines = part.labeledText["input"].trim().split("\n");
      for (const line of lines) {
        switch (line) {
          case "matriculation-number":
            this.requireMatriculationNumber = true;
            break;
          case "access-token":
            this.requireAccessToken = true;
            break;
          default:
            part.error = true;
            part.errorLog += 'unknown attribute "' + line + '".';
            break;
        }
      }
    }
  }
  toJson(json) {
    json["database"] = this.database;
    json["requireMatriculationNumber"] = this.requireMatriculationNumber;
    json["requireAccessToken"] = this.requireAccessToken;
  }
};

// src/compiler/document.ts
var Document = class {
  constructor() {
    this.type = "course-page";
    this.isAsciiMath = true;
    this.title = "";
    this.tags = [];
    this.parts = [];
    this.section = 1;
    this.subsection = 2;
    this.susubsection = 3;
    this.forceNewParagraph = false;
    this.oldOutput = null;
  }
  compile(input2, oldOutput2) {
    this.oldOutput = oldOutput2;
    const lines = input2.split("\n");
    const n = lines.length;
    for (let lineIdx = 0; lineIdx < n; lineIdx++) {
      let line = lines[lineIdx];
      if (line.trim().startsWith("%"))
        continue;
      if (line.trim().length == 0) {
        this.forceNewParagraph = true;
      } else if (line.startsWith("##### ")) {
        this.title = line.substring(6).trim();
      } else if (line.startsWith("=====")) {
        const part = new Part(lineIdx + 1);
        this.parts.push(part);
        part.type = "new-page" /* newPage */;
      } else if (line.startsWith("!")) {
        if (line.startsWith("!tex"))
          this.isAsciiMath = false;
      } else if (line.startsWith("# ")) {
        const part = new Part(lineIdx + 1);
        this.parts.push(part);
        part.type = "headline-1" /* headline1 */;
        part.text = this.section + ". " + line.substring(2).trim();
        this.section++;
        this.subsection = 1;
        this.susubsection = 1;
      } else if (line.startsWith("## ")) {
        const part = new Part(lineIdx + 1);
        this.parts.push(part);
        part.type = "headline-2" /* headline2 */;
        part.text = "" + (this.section - 1) + "." + this.subsection + " " + line.substring(2).trim();
        this.subsection++;
        this.susubsection = 1;
      } else if (line.startsWith("### ")) {
        const part = new Part(lineIdx + 1);
        this.parts.push(part);
        part.type = "headline-3" /* headline3 */;
        part.text = "" + (this.section - 1) + "." + (this.subsection - 1) + "." + this.susubsection + " " + line.substring(3).trim();
        this.susubsection++;
      } else if (line.startsWith("---")) {
        const part = new Part(lineIdx + 1);
        this.parts.push(part);
        part.type = "uncompiled-block" /* uncompiledBlock */;
        let textId = "";
        lineIdx++;
        let first = true;
        while (lineIdx < n) {
          line = lines[lineIdx];
          part.src += line + "\n";
          if (first) {
            part.id = line.trim();
          }
          if (line.startsWith("---")) {
            break;
          } else if (line.startsWith("@")) {
            textId = line.substring(1).trim();
          } else if (!first) {
            if (textId in part.labeledText == false)
              part.labeledText[textId] = line + "\n";
            else
              part.labeledText[textId] += line + "\n";
          }
          if (first)
            first = false;
          lineIdx++;
        }
        if (this.oldOutput != null) {
          const oldParts = this.oldOutput["parts"];
          for (const oldPart of oldParts) {
            if ("src" in oldPart && oldPart.src.length > 0 && oldPart.src === part.src) {
              part.type = oldPart.type;
              part.oldJson = oldPart;
            }
          }
        }
      } else {
        let part = null;
        if (!this.forceNewParagraph && this.parts.length > 0 && this.parts.slice(-1)[0].type == "paragraph" /* paragraph */) {
          part = this.parts.slice(-1)[0];
        } else {
          part = new Part(lineIdx + 1);
          part.type = "paragraph" /* paragraph */;
          this.parts.push(part);
        }
        part.text += line + "\n";
        this.forceNewParagraph = false;
      }
    }
    for (const part of this.parts) {
      if ("title" in part.labeledText)
        part.title = part.labeledText["title"];
      switch (part.type) {
        case "paragraph" /* paragraph */:
          part.text = this.compileParagraph(part.text);
          break;
        case "uncompiled-block" /* uncompiledBlock */:
          if (part.id === "Authentication.") {
            this.compileAuthentication(part);
          } else if (part.id === "Definition.") {
            this.compileDefinition(part);
          } else if (part.id === "Example.") {
            this.compileExample(part);
          } else if (part.id === "Question.") {
            this.compileQuestion(part);
          } else if (part.id === "Tikz.") {
            this.compileImage(part);
          } else if (part.id === "JavaQuestion.") {
            this.compileProgrammingQuestion("JavaProgram" /* JavaProgram */, part);
          } else {
            part.type = "error" /* error */;
            part.text = "error: unknown part type '" + part.id + "'";
          }
          break;
      }
    }
    return JSON.stringify(this.toJson(), null, 4);
  }
  compileAuthentication(part) {
    part.authentication = new Authentication();
    part.authentication.compileAuthentication(part);
  }
  compileDefinition(part) {
    part.type = "definition" /* definition */;
    part.text = this.compileParagraph(part.labeledText[""]);
  }
  compileExample(part) {
    part.type = "example" /* example */;
    part.text = this.compileParagraph(part.labeledText[""]);
  }
  compileQuestion(part) {
    part.question = new Question();
    part.question.compileQuestion(part, 5);
    part.question.text = this.compileParagraph(part.question.text);
    part.question.solutionText = this.compileParagraph(part.question.solutionText);
    for (let i = 0; i < part.question.variableTexts.length; i++) {
      part.question.variableTexts[i] = this.compileParagraph(part.question.variableTexts[i]);
    }
  }
  compileProgrammingQuestion(type, part) {
    part.programmingQuestion = new ProgrammingQuestion();
    part.programmingQuestion.compileProgrammingQuestion(part, type);
  }
  compileImage(part) {
    part.image = new Image();
    part.image.compileImage(part);
  }
  compileParagraph(text) {
    let res = "";
    const n = text.length;
    let isBold = false;
    let isItalic = false;
    let isList = false;
    let isListItem = false;
    let col = 0;
    for (let i = 0; i < n; i++) {
      const ch = text[i];
      if (col == 0 && text.substring(i).startsWith("```")) {
        res += '<code class="text-primary"><pre>';
        for (let j = i + 3; j < n; j++) {
          if (text.substring(j).startsWith("```")) {
            i = j + 2;
            break;
          }
          res += text[j];
        }
        res += "</pre></code>";
        continue;
      } else if (col == 0 && ch === "-") {
        if (isListItem)
          res += "</li>";
        if (!isList)
          res += "<ul>";
        isList = true;
        isListItem = true;
        res += "<li>";
        col++;
        continue;
      } else if (col == 0 && isList) {
        if (ch === " " || ch === "	") {
          res += "<br/>";
        } else {
          isListItem = false;
          isList = false;
          res += "</li></ul>";
        }
      }
      if (ch === "$") {
        let eqn = "";
        for (let j = i + 1; j < n; j++) {
          const ch2 = text[j];
          if (ch2 == "$") {
            i = j;
            break;
          }
          eqn += ch2;
        }
        res += "\\(" + eqn + "\\)";
      } else if (ch === "*") {
        if (text.substring(i).startsWith("**")) {
          i++;
          isBold = !isBold;
          res += isBold ? "<b>" : "</b>";
        } else {
          isItalic = !isItalic;
          res += isItalic ? "<i>" : "</i>";
        }
      } else if (ch === "\n") {
        col = -1;
        res += ch;
      } else {
        res += ch;
      }
      col++;
    }
    if (isBold)
      res += "</b>";
    if (isItalic)
      res += "</i>";
    if (isList)
      res += "</li></ul>";
    return res;
  }
  toJson() {
    const j = {};
    j.type = this.type;
    j.title = this.title;
    j.tags = this.tags;
    j.parts = [];
    for (const part of this.parts) {
      j.parts.push(part.toJson());
    }
    return j;
  }
};

// src/compiler/index.ts
if (import_process.default.argv.length != 4) {
  console.error("Error: usage: node compiler.ts INPUT_FILE_PATH OUTPUT_FILE_PATH");
  import_process.default.exit(-1);
}
var inputFilePath = import_process.default.argv[2];
var outputFilePath = import_process.default.argv[3];
if (import_fs4.default.existsSync(inputFilePath) == false) {
  console.error("error: input file " + inputFilePath + " does not exist");
  import_process.default.exit(-1);
}
var oldOutput = null;
if (import_fs4.default.existsSync(outputFilePath)) {
  oldOutput = JSON.parse(import_fs4.default.readFileSync(outputFilePath, "utf-8"));
}
console.log("converting " + inputFilePath + " to " + outputFilePath);
var doc = new Document();
var input = import_fs4.default.readFileSync(inputFilePath, "utf-8");
var output = doc.compile(input, oldOutput);
console.log("----- output -----");
console.log(output);
import_fs4.default.writeFileSync(outputFilePath, output);
